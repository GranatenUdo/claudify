# Kubernetes Deployment Template - Generated by Claudify
# Adapts to application requirements and best practices

apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${APP_NAME}-deployment
  namespace: ${NAMESPACE}
  labels:
    app: ${APP_NAME}
    version: ${APP_VERSION}
    component: ${COMPONENT_TYPE}
    ${IF_MULTI_TENANT}tenant: "shared"${END_IF}
spec:
  replicas: ${REPLICAS}
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: ${MAX_SURGE}
      maxUnavailable: ${MAX_UNAVAILABLE}
  selector:
    matchLabels:
      app: ${APP_NAME}
      component: ${COMPONENT_TYPE}
  template:
    metadata:
      labels:
        app: ${APP_NAME}
        version: ${APP_VERSION}
        component: ${COMPONENT_TYPE}
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "${METRICS_PORT}"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: ${SERVICE_ACCOUNT}
      ${IF_NODE_SELECTOR}
      nodeSelector:
        ${NODE_SELECTOR_LABELS}
      ${END_IF}
      
      ${IF_TOLERATIONS}
      tolerations:
        ${TOLERATIONS_CONFIG}
      ${END_IF}
      
      ${IF_AFFINITY}
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - ${APP_NAME}
              topologyKey: kubernetes.io/hostname
      ${END_IF}
      
      securityContext:
        runAsNonRoot: true
        runAsUser: ${USER_ID}
        fsGroup: ${GROUP_ID}
        ${IF_SECURITY_ENHANCED}
        seccompProfile:
          type: RuntimeDefault
        ${END_IF}
      
      containers:
      - name: ${APP_NAME}
        image: ${IMAGE_REPOSITORY}:${IMAGE_TAG}
        imagePullPolicy: ${IMAGE_PULL_POLICY}
        
        ports:
        - name: http
          containerPort: ${APP_PORT}
          protocol: TCP
        ${IF_METRICS_ENABLED}
        - name: metrics
          containerPort: ${METRICS_PORT}
          protocol: TCP
        ${END_IF}
        
        env:
        - name: ENVIRONMENT
          value: "${ENVIRONMENT}"
        - name: LOG_LEVEL
          value: "${LOG_LEVEL}"
        ${IF_MULTI_TENANT}
        - name: ENABLE_MULTI_TENANT
          value: "true"
        - name: TENANT_HEADER
          value: "${TENANT_HEADER}"
        ${END_IF}
        ${FOREACH_ENV_VAR}
        - name: ${ENV_NAME}
          value: "${ENV_VALUE}"
        ${END_FOREACH}
        ${FOREACH_SECRET_REF}
        - name: ${SECRET_ENV_NAME}
          valueFrom:
            secretKeyRef:
              name: ${SECRET_NAME}
              key: ${SECRET_KEY}
        ${END_FOREACH}
        ${IF_CONFIGMAP}
        envFrom:
        - configMapRef:
            name: ${APP_NAME}-config
        ${END_IF}
        
        resources:
          requests:
            cpu: ${CPU_REQUEST}
            memory: ${MEMORY_REQUEST}
            ${IF_EPHEMERAL_STORAGE}
            ephemeral-storage: ${EPHEMERAL_REQUEST}
            ${END_IF}
          limits:
            cpu: ${CPU_LIMIT}
            memory: ${MEMORY_LIMIT}
            ${IF_EPHEMERAL_STORAGE}
            ephemeral-storage: ${EPHEMERAL_LIMIT}
            ${END_IF}
        
        livenessProbe:
          ${LIVENESS_PROBE_TYPE}:
            ${IF_HTTP_PROBE}
            path: ${HEALTH_PATH}
            port: http
            scheme: ${HEALTH_SCHEME}
            ${END_IF}
            ${IF_TCP_PROBE}
            port: ${APP_PORT}
            ${END_IF}
            ${IF_EXEC_PROBE}
            command:
            ${FOREACH_PROBE_COMMAND}
            - ${COMMAND}
            ${END_FOREACH}
            ${END_IF}
          initialDelaySeconds: ${LIVENESS_INITIAL_DELAY}
          periodSeconds: ${LIVENESS_PERIOD}
          timeoutSeconds: ${LIVENESS_TIMEOUT}
          successThreshold: 1
          failureThreshold: ${LIVENESS_FAILURE_THRESHOLD}
        
        readinessProbe:
          ${READINESS_PROBE_TYPE}:
            ${IF_HTTP_PROBE}
            path: ${READY_PATH}
            port: http
            scheme: ${READY_SCHEME}
            ${END_IF}
            ${IF_TCP_PROBE}
            port: ${APP_PORT}
            ${END_IF}
          initialDelaySeconds: ${READINESS_INITIAL_DELAY}
          periodSeconds: ${READINESS_PERIOD}
          timeoutSeconds: ${READINESS_TIMEOUT}
          successThreshold: 1
          failureThreshold: ${READINESS_FAILURE_THRESHOLD}
        
        ${IF_STARTUP_PROBE}
        startupProbe:
          httpGet:
            path: ${STARTUP_PATH}
            port: http
          initialDelaySeconds: 0
          periodSeconds: ${STARTUP_PERIOD}
          timeoutSeconds: ${STARTUP_TIMEOUT}
          failureThreshold: ${STARTUP_FAILURE_THRESHOLD}
        ${END_IF}
        
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: ${READ_ONLY_ROOT}
          runAsNonRoot: true
          capabilities:
            drop:
            - ALL
            ${IF_CAPABILITIES_ADD}
            add:
            ${FOREACH_CAPABILITY}
            - ${CAPABILITY}
            ${END_FOREACH}
            ${END_IF}
        
        volumeMounts:
        ${IF_CONFIG_VOLUME}
        - name: config
          mountPath: /app/config
          readOnly: true
        ${END_IF}
        ${IF_SECRET_VOLUME}
        - name: secrets
          mountPath: /app/secrets
          readOnly: true
        ${END_IF}
        ${IF_PERSISTENT_VOLUME}
        - name: data
          mountPath: ${DATA_PATH}
        ${END_IF}
        ${IF_TEMP_VOLUME}
        - name: tmp
          mountPath: /tmp
        ${END_IF}
        ${FOREACH_VOLUME_MOUNT}
        - name: ${VOLUME_NAME}
          mountPath: ${MOUNT_PATH}
          ${IF_VOLUME_READONLY}readOnly: true${END_IF}
        ${END_FOREACH}
      
      ${IF_INIT_CONTAINERS}
      initContainers:
      ${FOREACH_INIT_CONTAINER}
      - name: ${INIT_NAME}
        image: ${INIT_IMAGE}
        command: ${INIT_COMMAND}
        ${IF_INIT_ENV}
        env:
        ${FOREACH_INIT_ENV}
        - name: ${INIT_ENV_NAME}
          value: "${INIT_ENV_VALUE}"
        ${END_FOREACH}
        ${END_IF}
      ${END_FOREACH}
      ${END_IF}
      
      volumes:
      ${IF_CONFIG_VOLUME}
      - name: config
        configMap:
          name: ${APP_NAME}-config
      ${END_IF}
      ${IF_SECRET_VOLUME}
      - name: secrets
        secret:
          secretName: ${APP_NAME}-secrets
          defaultMode: 0400
      ${END_IF}
      ${IF_PERSISTENT_VOLUME}
      - name: data
        persistentVolumeClaim:
          claimName: ${APP_NAME}-pvc
      ${END_IF}
      ${IF_TEMP_VOLUME}
      - name: tmp
        emptyDir: {}
      ${END_IF}
      ${FOREACH_VOLUME}
      - name: ${VOLUME_NAME}
        ${VOLUME_TYPE}:
          ${VOLUME_CONFIG}
      ${END_FOREACH}

---
apiVersion: v1
kind: Service
metadata:
  name: ${APP_NAME}-service
  namespace: ${NAMESPACE}
  labels:
    app: ${APP_NAME}
    component: ${COMPONENT_TYPE}
spec:
  type: ${SERVICE_TYPE}
  selector:
    app: ${APP_NAME}
    component: ${COMPONENT_TYPE}
  ports:
  - name: http
    port: ${SERVICE_PORT}
    targetPort: http
    protocol: TCP
  ${IF_METRICS_ENABLED}
  - name: metrics
    port: ${METRICS_PORT}
    targetPort: metrics
    protocol: TCP
  ${END_IF}
  ${IF_SESSION_AFFINITY}
  sessionAffinity: ClientIP
  sessionAffinityConfig:
    clientIP:
      timeoutSeconds: ${SESSION_TIMEOUT}
  ${END_IF}

${IF_INGRESS}
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ${APP_NAME}-ingress
  namespace: ${NAMESPACE}
  annotations:
    ${FOREACH_INGRESS_ANNOTATION}
    ${ANNOTATION_KEY}: "${ANNOTATION_VALUE}"
    ${END_FOREACH}
spec:
  ${IF_INGRESS_CLASS}
  ingressClassName: ${INGRESS_CLASS}
  ${END_IF}
  ${IF_TLS}
  tls:
  - hosts:
    - ${HOST}
    secretName: ${TLS_SECRET}
  ${END_IF}
  rules:
  - host: ${HOST}
    http:
      paths:
      - path: ${PATH}
        pathType: ${PATH_TYPE}
        backend:
          service:
            name: ${APP_NAME}-service
            port:
              number: ${SERVICE_PORT}
${END_IF}

${IF_HPA}
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: ${APP_NAME}-hpa
  namespace: ${NAMESPACE}
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: ${APP_NAME}-deployment
  minReplicas: ${MIN_REPLICAS}
  maxReplicas: ${MAX_REPLICAS}
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: ${CPU_TARGET_UTILIZATION}
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: ${MEMORY_TARGET_UTILIZATION}
  ${IF_CUSTOM_METRICS}
  ${FOREACH_CUSTOM_METRIC}
  - type: ${METRIC_TYPE}
    ${METRIC_CONFIG}
  ${END_FOREACH}
  ${END_IF}
  behavior:
    scaleDown:
      stabilizationWindowSeconds: ${SCALE_DOWN_STABILIZATION}
      policies:
      - type: Percent
        value: ${SCALE_DOWN_PERCENT}
        periodSeconds: ${SCALE_DOWN_PERIOD}
    scaleUp:
      stabilizationWindowSeconds: ${SCALE_UP_STABILIZATION}
      policies:
      - type: Percent
        value: ${SCALE_UP_PERCENT}
        periodSeconds: ${SCALE_UP_PERIOD}
${END_IF}

${IF_PDB}
---
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: ${APP_NAME}-pdb
  namespace: ${NAMESPACE}
spec:
  ${IF_MIN_AVAILABLE}
  minAvailable: ${MIN_AVAILABLE}
  ${END_IF}
  ${IF_MAX_UNAVAILABLE}
  maxUnavailable: ${MAX_UNAVAILABLE_PDB}
  ${END_IF}
  selector:
    matchLabels:
      app: ${APP_NAME}
      component: ${COMPONENT_TYPE}
${END_IF}

${IF_NETWORK_POLICY}
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: ${APP_NAME}-netpol
  namespace: ${NAMESPACE}
spec:
  podSelector:
    matchLabels:
      app: ${APP_NAME}
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    ${FOREACH_INGRESS_RULE}
    - ${INGRESS_RULE_TYPE}:
        ${INGRESS_RULE_CONFIG}
    ${END_FOREACH}
    ports:
    - protocol: TCP
      port: ${APP_PORT}
  egress:
  - to:
    ${FOREACH_EGRESS_RULE}
    - ${EGRESS_RULE_TYPE}:
        ${EGRESS_RULE_CONFIG}
    ${END_FOREACH}
    ports:
    ${FOREACH_EGRESS_PORT}
    - protocol: ${EGRESS_PROTOCOL}
      port: ${EGRESS_PORT}
    ${END_FOREACH}
${END_IF}